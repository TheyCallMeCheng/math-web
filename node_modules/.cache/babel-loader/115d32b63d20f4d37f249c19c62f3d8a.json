{"ast":null,"code":"'use strict';\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\n\nconst toCIDAndPath = require('ipfs-core-utils/src/to-cid-and-path');\n\nconst {\n  CID\n} = require('multiformats/cid'); // @ts-expect-error no types\n\n\nconst TimeoutController = require('timeout-abort-controller');\n\nconst {\n  anySignal\n} = require('any-signal');\n\nconst Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n};\n/**\n * @typedef {object} Node\n * @property {string} [name]\n * @property {CID} cid\n *\n * @typedef {object} TraversalResult\n * @property {Node} parent\n * @property {Node} node\n * @property {boolean} isDuplicate\n *\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-core-types/src/root').API[\"resolve\"]} config.resolve\n * @param {import('../../types').Preload} config.preload\n */\n\nmodule.exports = function ({\n  repo,\n  codecs,\n  resolve,\n  preload\n}) {\n  /**\n   * @type {import('ipfs-core-types/src/refs').API[\"refs\"]}\n   */\n  async function* refs(ipfsPath, options = {}) {\n    if (options.maxDepth === 0) {\n      return;\n    }\n\n    if (options.edges && options.format && options.format !== Format.default) {\n      throw new Error('Cannot set edges to true and also specify format');\n    }\n\n    options.format = options.edges ? Format.edges : options.format;\n\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1;\n    }\n\n    if (options.timeout) {\n      const controller = new TimeoutController(options.timeout);\n      options.signal = anySignal([options.signal, controller.signal]);\n    }\n    /** @type {(string|CID)[]} */\n\n\n    const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath];\n    const paths = rawPaths.map(p => getFullPath(preload, p, options));\n\n    for (const path of paths) {\n      try {\n        yield* refsStream(resolve, repo, codecs, path, options);\n      } catch (err) {\n        yield {\n          ref: '',\n          err: err.message\n        };\n      }\n    }\n  }\n\n  return refs;\n};\n\nmodule.exports.Format = Format;\n/**\n * @param {import('../../types').Preload} preload\n * @param {string | CID} ipfsPath\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\n\nfunction getFullPath(preload, ipfsPath, options) {\n  const {\n    cid,\n    path\n  } = toCIDAndPath(ipfsPath);\n\n  if (options.preload !== false) {\n    preload(cid);\n  }\n\n  return `/ipfs/${cid}${path || ''}`;\n}\n/**\n * Get a stream of refs at the given path\n *\n * @param {import('ipfs-core-types/src/root').API[\"resolve\"]} resolve\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {string} path\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\n\n\nasync function* refsStream(resolve, repo, codecs, path, options) {\n  // Resolve to the target CID of the path\n  const resPath = await resolve(path, options);\n  const {\n    cid\n  } = toCIDAndPath(resPath);\n  const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity;\n  const unique = options.unique || false; // Traverse the DAG, converting it into a stream\n\n  for await (const obj of objectStream(repo, codecs, cid, maxDepth, unique, options)) {\n    // Root object will not have a parent\n    if (!obj.parent) {\n      continue;\n    } // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n\n\n    if (obj.isDuplicate) {\n      continue;\n    } // Format the links\n    // Clients expect refs to be in the format { ref: <ref> }\n\n\n    yield {\n      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n    };\n  }\n}\n/**\n * Get formatted link\n *\n * @param {CID} srcCid\n * @param {CID} dstCid\n * @param {string} [linkName]\n * @param {string} [format]\n */\n\n\nfunction formatLink(srcCid, dstCid, linkName = '', format = Format.default) {\n  let out = format.replace(/<src>/g, srcCid.toString());\n  out = out.replace(/<dst>/g, dstCid.toString());\n  out = out.replace(/<linkname>/g, linkName);\n  return out;\n}\n/**\n * Do a depth first search of the DAG, starting from the given root cid\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID} rootCid\n * @param {number} maxDepth\n * @param {boolean} uniqueOnly\n * @param {AbortOptions} options\n */\n\n\nasync function* objectStream(repo, codecs, rootCid, maxDepth, uniqueOnly, options) {\n  // eslint-disable-line require-await\n  const seen = new Set();\n  /**\n   * @param {Node} parent\n   * @param {number} depth\n   * @returns {AsyncGenerator<TraversalResult, void, undefined>}\n   */\n\n  async function* traverseLevel(parent, depth) {\n    const nextLevelDepth = depth + 1; // Check the depth\n\n    if (nextLevelDepth > maxDepth) {\n      return;\n    } // Get this object's links\n\n\n    try {\n      // Look at each link, parent and the new depth\n      for await (const link of getLinks(repo, codecs, parent.cid, options)) {\n        yield {\n          parent: parent,\n          node: link,\n          isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n        };\n\n        if (uniqueOnly) {\n          seen.add(link.cid.toString());\n        }\n\n        yield* traverseLevel(link, nextLevelDepth);\n      }\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        err.message = `Could not find object with CID: ${parent.cid}`;\n      }\n\n      throw err;\n    }\n  }\n\n  yield* traverseLevel({\n    cid: rootCid\n  }, 0);\n}\n/**\n * Fetch a node and then get all its links\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID} cid\n * @param {AbortOptions} options\n * @returns {AsyncGenerator<{ name: string, cid: CID }, void, undefined>}\n */\n\n\nasync function* getLinks(repo, codecs, cid, options) {\n  const block = await repo.blocks.get(cid, options);\n  const codec = await codecs.getCodec(cid.code);\n  const value = codec.decode(block);\n  const isDagPb = cid.code === dagPb.code;\n  /** @type {Array<string|number>} */\n\n  const base = [];\n\n  for (const [name, cid] of links(value, base)) {\n    // special case for dag-pb - use the name of the link\n    // instead of the path within the object\n    if (isDagPb) {\n      const match = name.match(/^Links\\/(\\d+)\\/Hash$/);\n\n      if (match) {\n        const index = Number(match[1]);\n\n        if (index < value.Links.length) {\n          yield {\n            name: value.Links[index].Name,\n            cid\n          };\n          continue;\n        }\n      }\n    }\n\n    yield {\n      name,\n      cid\n    };\n  }\n}\n/**\n * @param {*} source\n * @param {Array<string|number>} base\n * @returns {Iterable<[string, CID]>}\n */\n\n\nconst links = function* (source, base) {\n  if (source == null) {\n    return;\n  }\n\n  if (source instanceof Uint8Array) {\n    return;\n  }\n\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key];\n\n    if (value != null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [...path, index];\n          const cid = CID.asCID(element); // eslint-disable-next-line max-depth\n\n          if (cid) {\n            yield [elementPath.join('/'), cid];\n          } else if (typeof element === 'object') {\n            yield* links(element, elementPath);\n          }\n        }\n      } else {\n        const cid = CID.asCID(value);\n\n        if (cid) {\n          yield [path.join('/'), cid];\n        } else {\n          yield* links(value, path);\n        }\n      }\n    }\n  } // ts requires a @returns annotation when a function is recursive,\n  // eslint requires a return when you use a @returns annotation.\n\n\n  return [];\n};","map":{"version":3,"sources":["/Users/marianionutcioancaradu/Documents/mathBlocks_web/mathblocks-web/node_modules/ipfs-core/src/components/refs/index.js"],"names":["dagPb","require","Errors","ERR_NOT_FOUND","notFoundError","code","toCIDAndPath","CID","TimeoutController","anySignal","Format","default","edges","module","exports","repo","codecs","resolve","preload","refs","ipfsPath","options","maxDepth","format","Error","recursive","Infinity","timeout","controller","signal","rawPaths","Array","isArray","paths","map","p","getFullPath","path","refsStream","err","ref","message","cid","resPath","unique","obj","objectStream","parent","isDuplicate","formatLink","node","name","srcCid","dstCid","linkName","out","replace","toString","rootCid","uniqueOnly","seen","Set","traverseLevel","depth","nextLevelDepth","link","getLinks","has","add","block","blocks","get","codec","getCodec","value","decode","isDagPb","base","links","match","index","Number","Links","length","Name","source","Uint8Array","key","Object","entries","element","elementPath","asCID","join"],"mappings":"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","sourcesContent":["'use strict'\n\nconst dagPb = require('@ipld/dag-pb')\nconst { Errors } = require('interface-datastore')\nconst ERR_NOT_FOUND = Errors.notFoundError().code\nconst toCIDAndPath = require('ipfs-core-utils/src/to-cid-and-path')\nconst { CID } = require('multiformats/cid')\n// @ts-expect-error no types\nconst TimeoutController = require('timeout-abort-controller')\nconst { anySignal } = require('any-signal')\n\nconst Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n}\n\n/**\n * @typedef {object} Node\n * @property {string} [name]\n * @property {CID} cid\n *\n * @typedef {object} TraversalResult\n * @property {Node} parent\n * @property {Node} node\n * @property {boolean} isDuplicate\n *\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-core-types/src/root').API[\"resolve\"]} config.resolve\n * @param {import('../../types').Preload} config.preload\n */\nmodule.exports = function ({ repo, codecs, resolve, preload }) {\n  /**\n   * @type {import('ipfs-core-types/src/refs').API[\"refs\"]}\n   */\n  async function * refs (ipfsPath, options = {}) {\n    if (options.maxDepth === 0) {\n      return\n    }\n\n    if (options.edges && options.format && options.format !== Format.default) {\n      throw new Error('Cannot set edges to true and also specify format')\n    }\n\n    options.format = options.edges ? Format.edges : options.format\n\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1\n    }\n\n    if (options.timeout) {\n      const controller = new TimeoutController(options.timeout)\n\n      options.signal = anySignal([options.signal, controller.signal])\n    }\n\n    /** @type {(string|CID)[]} */\n    const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath]\n\n    const paths = rawPaths.map(p => getFullPath(preload, p, options))\n\n    for (const path of paths) {\n      try {\n        yield * refsStream(resolve, repo, codecs, path, options)\n      } catch (err) {\n        yield {\n          ref: '',\n          err: err.message\n        }\n      }\n    }\n  }\n\n  return refs\n}\n\nmodule.exports.Format = Format\n\n/**\n * @param {import('../../types').Preload} preload\n * @param {string | CID} ipfsPath\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\nfunction getFullPath (preload, ipfsPath, options) {\n  const {\n    cid,\n    path\n  } = toCIDAndPath(ipfsPath)\n\n  if (options.preload !== false) {\n    preload(cid)\n  }\n\n  return `/ipfs/${cid}${path || ''}`\n}\n\n/**\n * Get a stream of refs at the given path\n *\n * @param {import('ipfs-core-types/src/root').API[\"resolve\"]} resolve\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {string} path\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\nasync function * refsStream (resolve, repo, codecs, path, options) {\n  // Resolve to the target CID of the path\n  const resPath = await resolve(path, options)\n  const {\n    cid\n  } = toCIDAndPath(resPath)\n\n  const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity\n  const unique = options.unique || false\n\n  // Traverse the DAG, converting it into a stream\n  for await (const obj of objectStream(repo, codecs, cid, maxDepth, unique, options)) {\n    // Root object will not have a parent\n    if (!obj.parent) {\n      continue\n    }\n\n    // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n    if (obj.isDuplicate) {\n      continue\n    }\n\n    // Format the links\n    // Clients expect refs to be in the format { ref: <ref> }\n    yield {\n      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n    }\n  }\n}\n\n/**\n * Get formatted link\n *\n * @param {CID} srcCid\n * @param {CID} dstCid\n * @param {string} [linkName]\n * @param {string} [format]\n */\nfunction formatLink (srcCid, dstCid, linkName = '', format = Format.default) {\n  let out = format.replace(/<src>/g, srcCid.toString())\n  out = out.replace(/<dst>/g, dstCid.toString())\n  out = out.replace(/<linkname>/g, linkName)\n  return out\n}\n\n/**\n * Do a depth first search of the DAG, starting from the given root cid\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID} rootCid\n * @param {number} maxDepth\n * @param {boolean} uniqueOnly\n * @param {AbortOptions} options\n */\nasync function * objectStream (repo, codecs, rootCid, maxDepth, uniqueOnly, options) { // eslint-disable-line require-await\n  const seen = new Set()\n\n  /**\n   * @param {Node} parent\n   * @param {number} depth\n   * @returns {AsyncGenerator<TraversalResult, void, undefined>}\n   */\n  async function * traverseLevel (parent, depth) {\n    const nextLevelDepth = depth + 1\n\n    // Check the depth\n    if (nextLevelDepth > maxDepth) {\n      return\n    }\n\n    // Get this object's links\n    try {\n      // Look at each link, parent and the new depth\n      for await (const link of getLinks(repo, codecs, parent.cid, options)) {\n        yield {\n          parent: parent,\n          node: link,\n          isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n        }\n\n        if (uniqueOnly) {\n          seen.add(link.cid.toString())\n        }\n\n        yield * traverseLevel(link, nextLevelDepth)\n      }\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        err.message = `Could not find object with CID: ${parent.cid}`\n      }\n\n      throw err\n    }\n  }\n\n  yield * traverseLevel({ cid: rootCid }, 0)\n}\n\n/**\n * Fetch a node and then get all its links\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID} cid\n * @param {AbortOptions} options\n * @returns {AsyncGenerator<{ name: string, cid: CID }, void, undefined>}\n */\nasync function * getLinks (repo, codecs, cid, options) {\n  const block = await repo.blocks.get(cid, options)\n  const codec = await codecs.getCodec(cid.code)\n  const value = codec.decode(block)\n  const isDagPb = cid.code === dagPb.code\n  /** @type {Array<string|number>} */\n  const base = []\n\n  for (const [name, cid] of links(value, base)) {\n    // special case for dag-pb - use the name of the link\n    // instead of the path within the object\n    if (isDagPb) {\n      const match = name.match(/^Links\\/(\\d+)\\/Hash$/)\n\n      if (match) {\n        const index = Number(match[1])\n\n        if (index < value.Links.length) {\n          yield {\n            name: value.Links[index].Name,\n            cid\n          }\n\n          continue\n        }\n      }\n    }\n\n    yield {\n      name,\n      cid\n    }\n  }\n}\n\n/**\n * @param {*} source\n * @param {Array<string|number>} base\n * @returns {Iterable<[string, CID]>}\n */\nconst links = function * (source, base) {\n  if (source == null) {\n    return\n  }\n\n  if (source instanceof Uint8Array) {\n    return\n  }\n\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key]\n\n    if (value != null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [...path, index]\n          const cid = CID.asCID(element)\n\n          // eslint-disable-next-line max-depth\n          if (cid) {\n            yield [elementPath.join('/'), cid]\n          } else if (typeof element === 'object') {\n            yield * links(element, elementPath)\n          }\n        }\n      } else {\n        const cid = CID.asCID(value)\n\n        if (cid) {\n          yield [path.join('/'), cid]\n        } else {\n          yield * links(value, path)\n        }\n      }\n    }\n  }\n\n  // ts requires a @returns annotation when a function is recursive,\n  // eslint requires a return when you use a @returns annotation.\n  return []\n}\n"]},"metadata":{},"sourceType":"script"}