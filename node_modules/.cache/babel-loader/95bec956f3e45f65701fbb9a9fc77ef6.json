{"ast":null,"code":"'use strict'; // @ts-ignore\n\nconst KBuck = require('k-bucket');\n\nconst {\n  xor: uint8ArrayXor\n} = require('uint8arrays/xor');\n\nconst GENERATED_PREFIXES = require('./generated-prefix-list.json');\n\nconst {\n  sha256\n} = require('multiformats/hashes/sha2');\n\nconst crypto = require('libp2p-crypto');\n\nconst PeerId = require('peer-id');\n\nconst utils = require('../utils');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:dht:routing-table'), {\n  error: debug('libp2p:dht:routing-table:error')\n}); // @ts-ignore\n\nconst length = require('it-length');\n/**\n * @typedef {object} KBucketPeer\n * @property {Uint8Array} id\n * @property {PeerId} peer\n *\n * @typedef {object} KBucket\n * @property {Uint8Array} id\n * @property {KBucketPeer[]} contacts\n * @property {boolean} dontSplit\n * @property {KBucket} left\n * @property {KBucket} right\n *\n * @typedef {object} KBucketTree\n * @property {KBucket} root\n * @property {Uint8Array} localNodeId\n * @property {(event: string, callback: Function) => void} on\n * @property {(key: Uint8Array, count: number) => KBucketPeer[]} closest\n * @property {(key: Uint8Array) => KBucketPeer} closestPeer\n * @property {(key: Uint8Array) => void} remove\n * @property {(peer: KBucketPeer) => void} add\n * @property {() => number} count\n * @property {() => Iterable<KBucket>} toIterable\n */\n\n/**\n * Cannot generate random KadIds longer than this + 1\n */\n\n\nconst MAX_COMMON_PREFIX_LENGTH = 15;\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\n\nclass RoutingTable {\n  /**\n   * @param {import('../')} dht\n   * @param {object} [options]\n   * @param {number} [options.kBucketSize=20]\n   * @param {number} [options.refreshInterval=30000]\n   */\n  constructor(dht, {\n    kBucketSize,\n    refreshInterval\n  } = {}) {\n    this.peerId = dht.peerId;\n    this.dht = dht;\n    this._kBucketSize = kBucketSize || 20;\n    this._refreshInterval = refreshInterval || 30000;\n    /** @type {KBucketTree} */\n\n    this.kb = new KBuck({\n      numberOfNodesPerKBucket: this._kBucketSize,\n      numberOfNodesToPing: 1\n    });\n    /** @type {Date[]} */\n\n    this.commonPrefixLengthRefreshedAt = [];\n    this._refreshTable = this._refreshTable.bind(this);\n    this._onPing = this._onPing.bind(this);\n  }\n\n  async start() {\n    this.kb.localNodeId = await utils.convertPeerId(this.peerId);\n    this.kb.on('ping', this._onPing);\n    await this._refreshTable(true);\n  }\n\n  async stop() {\n    if (this._refreshTimeoutId) {\n      clearTimeout(this._refreshTimeoutId);\n    }\n  }\n  /**\n   * To speed lookups, we seed the table with random PeerIds. This means\n   * when we are asked to locate a peer on the network, we can find a KadId\n   * that is close to the requested peer ID and query that, then network\n   * peers will tell us who they know who is close to the fake ID\n   *\n   * @param {boolean} [force=false]\n   */\n\n\n  async _refreshTable(force) {\n    log('refreshing routing table');\n\n    const prefixLength = this._maxCommonPrefix();\n\n    const refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength);\n\n    log(`max common prefix length ${prefixLength}`);\n    log(`tracked CPLs [ ${refreshCpls.map(date => `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}`).join(', ')} ]`);\n    /**\n     * If we see a gap at a common prefix length in the Routing table, we ONLY refresh up until\n     * the maximum cpl we have in the Routing Table OR (2 * (Cpl+ 1) with the gap), whichever\n     * is smaller.\n     *\n     * This is to prevent refreshes for Cpls that have no peers in the network but happen to be\n     * before a very high max Cpl for which we do have peers in the network.\n     *\n     * The number of 2 * (Cpl + 1) can be proved and a proof would have been written here if\n     * the programmer had paid more attention in the Math classes at university.\n     *\n     * So, please be patient and a doc explaining it will be published soon.\n     *\n     * https://github.com/libp2p/go-libp2p-kad-dht/commit/2851c88acb0a3f86bcfe3cfd0f4604a03db801d8#diff-ad45f4ba97ffbc4083c2eb87a4420c1157057b233f048030d67c6b551855ccf6R219\n     */\n\n    await Promise.all(refreshCpls.map(async (lastRefresh, index) => {\n      try {\n        await this._refreshCommonPrefixLength(index, lastRefresh, force === true);\n\n        if (this._numPeersForCpl(prefixLength) === 0) {\n          const lastCpl = Math.min(2 * (index + 1), refreshCpls.length - 1);\n\n          for (let n = index + 1; n < lastCpl + 1; n++) {\n            try {\n              await this._refreshCommonPrefixLength(n, lastRefresh, force === true);\n            } catch (err) {\n              log.error(err);\n            }\n          }\n        }\n      } catch (err) {\n        log.error(err);\n      }\n    }));\n    this._refreshTimeoutId = setTimeout(this._refreshTable, this._refreshInterval); // @ts-ignore\n\n    this._refreshTimeoutId.unref();\n  }\n  /**\n   * @param {number} cpl\n   * @param {Date} lastRefresh\n   * @param {boolean} force\n   */\n\n\n  async _refreshCommonPrefixLength(cpl, lastRefresh, force) {\n    if (!force && lastRefresh.getTime() > Date.now() - this._refreshInterval) {\n      log(`not running refresh for cpl ${cpl} as time since last refresh not above interval`);\n      return;\n    } // gen a key for the query to refresh the cpl\n\n\n    const peerId = await this._generateRandomPeerId(cpl);\n    log(`starting refreshing cpl ${cpl} with key ${peerId.toB58String()} (routing table size was ${this.kb.count()})`);\n    const peers = await length(this.dht.getClosestPeers(peerId.toBytes(), {}));\n    log(`found ${peers} peers that were close to imaginary peer ${peerId.toB58String()}`);\n    log(`finished refreshing cpl ${cpl} with key ${peerId.toB58String()} (routing table size was ${this.kb.count()})`);\n  }\n  /**\n   * @param {number} maxCommonPrefix\n   */\n\n\n  _getTrackedCommonPrefixLengthsForRefresh(maxCommonPrefix) {\n    if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {\n      maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH;\n    }\n\n    const dates = [];\n\n    for (let i = 0; i <= maxCommonPrefix; i++) {\n      // defaults to the zero value if we haven't refreshed it yet.\n      dates[i] = this.commonPrefixLengthRefreshedAt[i] || new Date();\n    }\n\n    return dates;\n  }\n  /**\n   *\n   * @param {number} targetCommonPrefixLength\n   */\n\n\n  async _generateRandomPeerId(targetCommonPrefixLength) {\n    const randomBytes = crypto.randomBytes(2);\n    const randomUint16 = (randomBytes[1] << 8) + randomBytes[0];\n    const key = await this._makePeerId(this.kb.localNodeId, randomUint16, targetCommonPrefixLength);\n    return PeerId.createFromBytes(key);\n  }\n  /**\n   * @param {Uint8Array} localKadId\n   * @param {number} randomPrefix\n   * @param {number} targetCommonPrefixLength\n   */\n\n\n  async _makePeerId(localKadId, randomPrefix, targetCommonPrefixLength) {\n    if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {\n      throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`);\n    }\n\n    const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength);\n    const localPrefix = view.getUint16(0, false); // For host with ID `L`, an ID `K` belongs to a bucket with ID `B` ONLY IF CommonPrefixLen(L,K) is EXACTLY B.\n    // Hence, to achieve a targetPrefix `T`, we must toggle the (T+1)th bit in L & then copy (T+1) bits from L\n    // to our randomly generated prefix.\n\n    const toggledLocalPrefix = localPrefix ^ 0x8000 >> targetCommonPrefixLength; // Combine the toggled local prefix and the random bits at the correct offset\n    // such that ONLY the first `targetCommonPrefixLength` bits match the local ID.\n\n    const mask = 65535 << 16 - (targetCommonPrefixLength + 1);\n    const targetPrefix = toggledLocalPrefix & mask | randomPrefix & ~mask; // Convert to a known peer ID.\n\n    const keyPrefix = GENERATED_PREFIXES[targetPrefix];\n    const keyBuffer = new ArrayBuffer(34);\n    const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength);\n    keyView.setUint8(0, sha256.code);\n    keyView.setUint8(1, 32);\n    keyView.setUint32(2, keyPrefix, false);\n    return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength);\n  }\n  /**\n   * returns the maximum common prefix length between any peer in the table\n   * and the current peer\n   */\n\n\n  _maxCommonPrefix() {\n    if (!this.kb.localNodeId) {\n      return 0;\n    } // xor our KadId with every KadId in the k-bucket tree,\n    // return the longest id prefix that is the same\n\n\n    let prefixLength = 0;\n\n    for (const length of this._prefixLengths()) {\n      if (length > prefixLength) {\n        prefixLength = length;\n      }\n    }\n\n    return prefixLength;\n  }\n  /**\n   * Returns the number of peers in the table with a given prefix length\n   *\n   * @param {number} prefixLength\n   */\n\n\n  _numPeersForCpl(prefixLength) {\n    let count = 0;\n\n    for (const length of this._prefixLengths()) {\n      if (length === prefixLength) {\n        count++;\n      }\n    }\n\n    return count;\n  }\n  /**\n   * Yields the common prefix length of every peer in the table\n   */\n\n\n  *_prefixLengths() {\n    for (const {\n      id\n    } of this.kb.toIterable()) {\n      const distance = uint8ArrayXor(this.kb.localNodeId, id);\n      let leadingZeros = 0;\n\n      for (const byte of distance) {\n        if (byte === 0) {\n          leadingZeros++;\n        } else {\n          break;\n        }\n      }\n\n      yield leadingZeros;\n    }\n  }\n  /**\n   * Called on the `ping` event from `k-bucket`.\n   * Currently this just removes the oldest contact from\n   * the list, without actually pinging the individual peers.\n   * This is the same as go does, but should probably\n   * be upgraded to actually ping the individual peers.\n   *\n   * @param {KBucketPeer[]} oldContacts\n   * @param {KBucketPeer} newContact\n   */\n\n\n  _onPing(oldContacts, newContact) {\n    // just use the first one (k-bucket sorts from oldest to newest)\n    const oldest = oldContacts[0];\n\n    if (oldest) {\n      // remove the oldest one\n      this.kb.remove(oldest.id);\n    } // add the new one\n\n\n    this.kb.add(newContact);\n  } // -- Public Interface\n\n  /**\n   * Amount of currently stored peers.\n   */\n\n\n  get size() {\n    return this.kb.count();\n  }\n  /**\n   * Find a specific peer by id.\n   *\n   * @param {PeerId} peer\n   */\n\n\n  async find(peer) {\n    const key = await utils.convertPeerId(peer);\n    const closest = this.closestPeer(key);\n\n    if (closest && peer.equals(closest)) {\n      return closest;\n    }\n  }\n  /**\n   * Retrieve the closest peers to the given key.\n   *\n   * @param {Uint8Array} key\n   */\n\n\n  closestPeer(key) {\n    const res = this.closestPeers(key, 1);\n\n    if (res.length > 0) {\n      return res[0];\n    }\n  }\n  /**\n   * Retrieve the `count`-closest peers to the given key.\n   *\n   * @param {Uint8Array} key\n   * @param {number} count\n   */\n\n\n  closestPeers(key, count) {\n    const closest = this.kb.closest(key, count);\n    return closest.map(p => p.peer);\n  }\n  /**\n   * Add or update the routing table with the given peer.\n   *\n   * @param {PeerId} peer\n   */\n\n\n  async add(peer) {\n    const id = await utils.convertPeerId(peer);\n    this.kb.add({\n      id: id,\n      peer: peer\n    });\n  }\n  /**\n   * Remove a given peer from the table.\n   *\n   * @param {PeerId} peer\n   */\n\n\n  async remove(peer) {\n    const id = await utils.convertPeerId(peer);\n    this.kb.remove(id);\n  }\n\n}\n\nmodule.exports = RoutingTable;","map":{"version":3,"sources":["/Users/marianionutcioancaradu/Documents/mathBlocks_web/mathblocks-web/node_modules/libp2p-kad-dht/src/routing-table/index.js"],"names":["KBuck","require","xor","uint8ArrayXor","GENERATED_PREFIXES","sha256","crypto","PeerId","utils","debug","log","Object","assign","error","length","MAX_COMMON_PREFIX_LENGTH","RoutingTable","constructor","dht","kBucketSize","refreshInterval","peerId","_kBucketSize","_refreshInterval","kb","numberOfNodesPerKBucket","numberOfNodesToPing","commonPrefixLengthRefreshedAt","_refreshTable","bind","_onPing","start","localNodeId","convertPeerId","on","stop","_refreshTimeoutId","clearTimeout","force","prefixLength","_maxCommonPrefix","refreshCpls","_getTrackedCommonPrefixLengthsForRefresh","map","date","getFullYear","getMonth","toString","padStart","getDate","getHours","getMinutes","getSeconds","join","Promise","all","lastRefresh","index","_refreshCommonPrefixLength","_numPeersForCpl","lastCpl","Math","min","n","err","setTimeout","unref","cpl","getTime","Date","now","_generateRandomPeerId","toB58String","count","peers","getClosestPeers","toBytes","maxCommonPrefix","dates","i","targetCommonPrefixLength","randomBytes","randomUint16","key","_makePeerId","createFromBytes","localKadId","randomPrefix","Error","view","DataView","buffer","byteOffset","byteLength","localPrefix","getUint16","toggledLocalPrefix","mask","targetPrefix","keyPrefix","keyBuffer","ArrayBuffer","keyView","setUint8","code","setUint32","Uint8Array","_prefixLengths","id","toIterable","distance","leadingZeros","byte","oldContacts","newContact","oldest","remove","add","size","find","peer","closest","closestPeer","equals","res","closestPeers","p","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\n// @ts-ignore\nconst KBuck = require('k-bucket')\nconst { xor: uint8ArrayXor } = require('uint8arrays/xor')\nconst GENERATED_PREFIXES = require('./generated-prefix-list.json')\nconst { sha256 } = require('multiformats/hashes/sha2')\nconst crypto = require('libp2p-crypto')\nconst PeerId = require('peer-id')\nconst utils = require('../utils')\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:dht:routing-table'), {\n  error: debug('libp2p:dht:routing-table:error')\n})\n// @ts-ignore\nconst length = require('it-length')\n\n/**\n * @typedef {object} KBucketPeer\n * @property {Uint8Array} id\n * @property {PeerId} peer\n *\n * @typedef {object} KBucket\n * @property {Uint8Array} id\n * @property {KBucketPeer[]} contacts\n * @property {boolean} dontSplit\n * @property {KBucket} left\n * @property {KBucket} right\n *\n * @typedef {object} KBucketTree\n * @property {KBucket} root\n * @property {Uint8Array} localNodeId\n * @property {(event: string, callback: Function) => void} on\n * @property {(key: Uint8Array, count: number) => KBucketPeer[]} closest\n * @property {(key: Uint8Array) => KBucketPeer} closestPeer\n * @property {(key: Uint8Array) => void} remove\n * @property {(peer: KBucketPeer) => void} add\n * @property {() => number} count\n * @property {() => Iterable<KBucket>} toIterable\n */\n\n/**\n * Cannot generate random KadIds longer than this + 1\n */\nconst MAX_COMMON_PREFIX_LENGTH = 15\n\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\nclass RoutingTable {\n  /**\n   * @param {import('../')} dht\n   * @param {object} [options]\n   * @param {number} [options.kBucketSize=20]\n   * @param {number} [options.refreshInterval=30000]\n   */\n  constructor (dht, { kBucketSize, refreshInterval } = {}) {\n    this.peerId = dht.peerId\n    this.dht = dht\n    this._kBucketSize = kBucketSize || 20\n    this._refreshInterval = refreshInterval || 30000\n\n    /** @type {KBucketTree} */\n    this.kb = new KBuck({\n      numberOfNodesPerKBucket: this._kBucketSize,\n      numberOfNodesToPing: 1\n    })\n\n    /** @type {Date[]} */\n    this.commonPrefixLengthRefreshedAt = []\n\n    this._refreshTable = this._refreshTable.bind(this)\n    this._onPing = this._onPing.bind(this)\n  }\n\n  async start () {\n    this.kb.localNodeId = await utils.convertPeerId(this.peerId)\n    this.kb.on('ping', this._onPing)\n\n    await this._refreshTable(true)\n  }\n\n  async stop () {\n    if (this._refreshTimeoutId) {\n      clearTimeout(this._refreshTimeoutId)\n    }\n  }\n\n  /**\n   * To speed lookups, we seed the table with random PeerIds. This means\n   * when we are asked to locate a peer on the network, we can find a KadId\n   * that is close to the requested peer ID and query that, then network\n   * peers will tell us who they know who is close to the fake ID\n   *\n   * @param {boolean} [force=false]\n   */\n  async _refreshTable (force) {\n    log('refreshing routing table')\n\n    const prefixLength = this._maxCommonPrefix()\n    const refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength)\n\n    log(`max common prefix length ${prefixLength}`)\n    log(`tracked CPLs [ ${refreshCpls.map(date => `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}`).join(', ')} ]`)\n\n    /**\n     * If we see a gap at a common prefix length in the Routing table, we ONLY refresh up until\n     * the maximum cpl we have in the Routing Table OR (2 * (Cpl+ 1) with the gap), whichever\n     * is smaller.\n     *\n     * This is to prevent refreshes for Cpls that have no peers in the network but happen to be\n     * before a very high max Cpl for which we do have peers in the network.\n     *\n     * The number of 2 * (Cpl + 1) can be proved and a proof would have been written here if\n     * the programmer had paid more attention in the Math classes at university.\n     *\n     * So, please be patient and a doc explaining it will be published soon.\n     *\n     * https://github.com/libp2p/go-libp2p-kad-dht/commit/2851c88acb0a3f86bcfe3cfd0f4604a03db801d8#diff-ad45f4ba97ffbc4083c2eb87a4420c1157057b233f048030d67c6b551855ccf6R219\n     */\n    await Promise.all(\n      refreshCpls.map(async (lastRefresh, index) => {\n        try {\n          await this._refreshCommonPrefixLength(index, lastRefresh, force === true)\n\n          if (this._numPeersForCpl(prefixLength) === 0) {\n            const lastCpl = Math.min(2 * (index + 1), refreshCpls.length - 1)\n\n            for (let n = index + 1; n < lastCpl + 1; n++) {\n              try {\n                await this._refreshCommonPrefixLength(n, lastRefresh, force === true)\n              } catch (err) {\n                log.error(err)\n              }\n            }\n          }\n        } catch (err) {\n          log.error(err)\n        }\n      })\n    )\n\n    this._refreshTimeoutId = setTimeout(this._refreshTable, this._refreshInterval)\n    // @ts-ignore\n    this._refreshTimeoutId.unref()\n  }\n\n  /**\n   * @param {number} cpl\n   * @param {Date} lastRefresh\n   * @param {boolean} force\n   */\n  async _refreshCommonPrefixLength (cpl, lastRefresh, force) {\n    if (!force && lastRefresh.getTime() > (Date.now() - this._refreshInterval)) {\n      log(`not running refresh for cpl ${cpl} as time since last refresh not above interval`)\n      return\n    }\n\n    // gen a key for the query to refresh the cpl\n    const peerId = await this._generateRandomPeerId(cpl)\n\n    log(`starting refreshing cpl ${cpl} with key ${peerId.toB58String()} (routing table size was ${this.kb.count()})`)\n\n    const peers = await length(this.dht.getClosestPeers(peerId.toBytes(), {}))\n\n    log(`found ${peers} peers that were close to imaginary peer ${peerId.toB58String()}`)\n\n    log(`finished refreshing cpl ${cpl} with key ${peerId.toB58String()} (routing table size was ${this.kb.count()})`)\n  }\n\n  /**\n   * @param {number} maxCommonPrefix\n   */\n  _getTrackedCommonPrefixLengthsForRefresh (maxCommonPrefix) {\n    if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {\n      maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH\n    }\n\n    const dates = []\n\n    for (let i = 0; i <= maxCommonPrefix; i++) {\n      // defaults to the zero value if we haven't refreshed it yet.\n      dates[i] = this.commonPrefixLengthRefreshedAt[i] || new Date()\n    }\n\n    return dates\n  }\n\n  /**\n   *\n   * @param {number} targetCommonPrefixLength\n   */\n  async _generateRandomPeerId (targetCommonPrefixLength) {\n    const randomBytes = crypto.randomBytes(2)\n    const randomUint16 = (randomBytes[1] << 8) + randomBytes[0]\n\n    const key = await this._makePeerId(this.kb.localNodeId, randomUint16, targetCommonPrefixLength)\n\n    return PeerId.createFromBytes(key)\n  }\n\n  /**\n   * @param {Uint8Array} localKadId\n   * @param {number} randomPrefix\n   * @param {number} targetCommonPrefixLength\n   */\n  async _makePeerId (localKadId, randomPrefix, targetCommonPrefixLength) {\n    if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {\n      throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`)\n    }\n\n    const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength)\n    const localPrefix = view.getUint16(0, false)\n\n    // For host with ID `L`, an ID `K` belongs to a bucket with ID `B` ONLY IF CommonPrefixLen(L,K) is EXACTLY B.\n    // Hence, to achieve a targetPrefix `T`, we must toggle the (T+1)th bit in L & then copy (T+1) bits from L\n    // to our randomly generated prefix.\n    const toggledLocalPrefix = localPrefix ^ (0x8000 >> targetCommonPrefixLength)\n\n    // Combine the toggled local prefix and the random bits at the correct offset\n    // such that ONLY the first `targetCommonPrefixLength` bits match the local ID.\n    const mask = 65535 << (16 - (targetCommonPrefixLength + 1))\n    const targetPrefix = (toggledLocalPrefix & mask) | (randomPrefix & ~mask)\n\n    // Convert to a known peer ID.\n    const keyPrefix = GENERATED_PREFIXES[targetPrefix]\n\n    const keyBuffer = new ArrayBuffer(34)\n    const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength)\n    keyView.setUint8(0, sha256.code)\n    keyView.setUint8(1, 32)\n    keyView.setUint32(2, keyPrefix, false)\n\n    return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength)\n  }\n\n  /**\n   * returns the maximum common prefix length between any peer in the table\n   * and the current peer\n   */\n  _maxCommonPrefix () {\n    if (!this.kb.localNodeId) {\n      return 0\n    }\n\n    // xor our KadId with every KadId in the k-bucket tree,\n    // return the longest id prefix that is the same\n    let prefixLength = 0\n\n    for (const length of this._prefixLengths()) {\n      if (length > prefixLength) {\n        prefixLength = length\n      }\n    }\n\n    return prefixLength\n  }\n\n  /**\n   * Returns the number of peers in the table with a given prefix length\n   *\n   * @param {number} prefixLength\n   */\n  _numPeersForCpl (prefixLength) {\n    let count = 0\n\n    for (const length of this._prefixLengths()) {\n      if (length === prefixLength) {\n        count++\n      }\n    }\n\n    return count\n  }\n\n  /**\n   * Yields the common prefix length of every peer in the table\n   */\n  * _prefixLengths () {\n    for (const { id } of this.kb.toIterable()) {\n      const distance = uint8ArrayXor(this.kb.localNodeId, id)\n      let leadingZeros = 0\n\n      for (const byte of distance) {\n        if (byte === 0) {\n          leadingZeros++\n        } else {\n          break\n        }\n      }\n\n      yield leadingZeros\n    }\n  }\n\n  /**\n   * Called on the `ping` event from `k-bucket`.\n   * Currently this just removes the oldest contact from\n   * the list, without actually pinging the individual peers.\n   * This is the same as go does, but should probably\n   * be upgraded to actually ping the individual peers.\n   *\n   * @param {KBucketPeer[]} oldContacts\n   * @param {KBucketPeer} newContact\n   */\n  _onPing (oldContacts, newContact) {\n    // just use the first one (k-bucket sorts from oldest to newest)\n    const oldest = oldContacts[0]\n\n    if (oldest) {\n      // remove the oldest one\n      this.kb.remove(oldest.id)\n    }\n\n    // add the new one\n    this.kb.add(newContact)\n  }\n\n  // -- Public Interface\n\n  /**\n   * Amount of currently stored peers.\n   */\n  get size () {\n    return this.kb.count()\n  }\n\n  /**\n   * Find a specific peer by id.\n   *\n   * @param {PeerId} peer\n   */\n  async find (peer) {\n    const key = await utils.convertPeerId(peer)\n    const closest = this.closestPeer(key)\n\n    if (closest && peer.equals(closest)) {\n      return closest\n    }\n  }\n\n  /**\n   * Retrieve the closest peers to the given key.\n   *\n   * @param {Uint8Array} key\n   */\n  closestPeer (key) {\n    const res = this.closestPeers(key, 1)\n\n    if (res.length > 0) {\n      return res[0]\n    }\n  }\n\n  /**\n   * Retrieve the `count`-closest peers to the given key.\n   *\n   * @param {Uint8Array} key\n   * @param {number} count\n   */\n  closestPeers (key, count) {\n    const closest = this.kb.closest(key, count)\n\n    return closest.map(p => p.peer)\n  }\n\n  /**\n   * Add or update the routing table with the given peer.\n   *\n   * @param {PeerId} peer\n   */\n  async add (peer) {\n    const id = await utils.convertPeerId(peer)\n\n    this.kb.add({ id: id, peer: peer })\n  }\n\n  /**\n   * Remove a given peer from the table.\n   *\n   * @param {PeerId} peer\n   */\n  async remove (peer) {\n    const id = await utils.convertPeerId(peer)\n\n    this.kb.remove(id)\n  }\n}\n\nmodule.exports = RoutingTable\n"]},"metadata":{},"sourceType":"script"}